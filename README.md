# fusepy_vulnerability_experiment

I'm anticipating some aprehension about using fuse at work since it's possible to write a virtual filesystem for FUSE (fusermount runs suid root) where the UIDs, GIDs, and permission bits shown to people using the virtual filesystem can be set to root, root, SUID respectively. Some may think this means that one could write a malicious program to gain root privileges when executed through the filesystem. FUSE has you covered though. Try the following:


 

```bash
gcc -o getuid getuid.c
sudo chown root getuid
chmod 4755 getuid
ls -al getuid # note the SUID bit
./getuid
```

See EFFECTIVE UID 0? That's root, and that makes sense because we changed the owner of ./getuid to root and set the SUID bit
Now let's set it back to our own username and get rid of the SUID bit:

```bash
sudo chown $(whoami) getuid
chmod 755 getuid
ls -al # note the owner and permission bits now
```

Now let's make a virtual filesystem that passes our potentially malicious binary through but presents different owners & permission bits

mkdir -p mountpoint_parent/mountpoint
python fuse_passthrough.py . mountpoint_parent/mountpoint
```

Then in another terminal:

```bash
# cd to the dir where this repo is
ls -al mountpoint_parent/mountpoint # note everything being "owned" by root with setuid bits set

# run our 'malicious' program
mountpoint_parent/mountpoint/setuid

# note the effective UID and the REAL UID are the same, and neither is root (unless you are indeed root at the time)
```
